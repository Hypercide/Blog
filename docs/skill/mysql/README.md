# MySQL

## 数据库三范式
- 第一范式
    - 属性的原子性，字段不可再分割
- 第二范式
    - 记录的唯一性，记录有唯一标识(即主键)，其他字段依赖于主键
- 第三范式
    - 消除传递依赖，字段没有冗余，不存在传递依赖

## 什么叫事务？简称`ACID`

- A 事务的`原子性`(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.

- C 事务的`一致性`(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.

- I `独立性`(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.

- D `持久性`(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.

## MySQL各个存储引擎比较
MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。

存储引擎主要有： 1. `MyIsam` , 2. `InnoDB`, 3. `Memory`, 4. `Blackhole`, 5. `CSV`, 6. `Performance_Schema`, 7. `Archive`, 8. `Federated`, 9. `Mrg_Myisam`

主要分析使用`MyIsam`和`InnoDB`，这两种引擎的数据结构都是B+树。

存储的不同： 
`MyIsam`树节点存储得是数据的地址，指向实际的数据； 
`InnoDB`树节点存储得是实际的数据；这种索引也被称为聚集索引

**基本的差别为：`MyIsam`类型不支持事务处理等高级处理，而`InnoDB`类型支持。`MyIsam`类型的表强调的是性能，其执行数度比`InnoDB`类型更快，但是不提供事务支持，而`InnoDB`提供事务支持已经外部键等高级数据库功能。**

### MyIsam
这个是5.5版本之前的默认引擎，不提供事务和行级锁和外键约束，当在`insert`和`update`时会锁定全表，所以在执行写操作对的时候效率会很慢， 
和`innodb`不同的是，`myiasm`保留了行数，所以在执行`select count（*） from `的时候会很快，不需要扫描全表，当我们执行的读操作多于写操作的时候，并且不需要事务的支持，我们可以使用`myisam`这个引擎。
引擎在创建表的时候，会创建三个文件：
1. 用于存储表的定义`.frm`文件
2. 用于存储表的数据`.MYD`文件
3. 用于存储的是索引`.MYI`文件
操作系统对大文件的操作是比较慢的，这样将表分为三个文件，平均分配`IO`，那么`.MYD`这个文件单独来存放数据自然可以优化数据库的查询等操作。
#### MyISAM引擎调优
1. 设置合适的索引（缓存机制）
2. 调整读写优先级，根据实际需求确保重要操作更优先执行。
3. 启用延迟插入改善大批量写入性能（降低写入频率，尽可能多条数据一次性写入）
4. 尽量顺序操作让`insert`数据都写入到尾部，减少阻塞。
5. 分解大的时间长的操作，降低单个操作的阻塞时间。
6. 降低并发数（减少对`mysql`访问），某些高并发场景通过应用进行排队队列机制Q队列
7. 对于相对静态（更改不频繁）的数据库数据，充分利用`Query Cache`或`memcached`缓存服务可以极大的提高访问效率。
8. `MyISAM`的`count`只有在全表扫描的时候特别高效，带有其他条件的`count`都需要进行实际的数据访问`select count(*) from oldboy.zizeng`;
9. 可以把主从同步的主库使用`innodb`,从库使用`myisam`引擎（但是在为了主从切换的时候还是要用`innodb`，所以这个不现实。）

### InnoDB
`InnoDB`是一个事务型的存储引擎，有行级锁定和外键约束。
1. 支持事务，完美的`ACID`兼容
2. 具有提交、回滚和崩溃恢复能力，通过`bin-log`日志可以从灾难中恢复
3. 行级锁定可以让并发较高时，使用`Innodb`引擎会提升效率
4. 外键约束可以实现级联更新，级联删除等操作
5. 具有非常高效的缓存特性：能缓存索引，也能缓存数据

#### InnoDB引擎调优
1. 主键要尽可能小，避免给`secondary index`带来过大的空间负担。
2. 避免全表扫描，因为会使用表锁
3. 尽可能缓存所有的索引和数据，提高响应速度，减少磁盘`IO`消耗。
4. 在大批量小插入的时候，尽量自己控制事务而不要使用`autocommit`自动提交，有开关可以控制提交方式。
5. 合理设置`innodb_flush_log_at_trx_commit`参数值，不要过度追求安全性。如果`innodb_flush_log_at_trx_commit`的值为`0`，`log buffer`每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作。
6. 避免主键更新，因为这会带来大量的数据移动。