(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{281:function(t,a,v){"use strict";v.r(a);var _=v(22),e=Object(_.a)({},function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"高并发与高可用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高并发与高可用","aria-hidden":"true"}},[t._v("#")]),t._v(" 高并发与高可用")]),t._v(" "),v("h2",{attrs:{id:"缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),v("h3",{attrs:{id:"缓存穿透"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透","aria-hidden":"true"}},[t._v("#")]),t._v(" 缓存穿透")]),t._v(" "),v("p",[v("code",[t._v("缓存穿透")]),t._v("是指查询一个根本不存在的数据，缓存层和存储层都不命中，但是出于容错的考虑，如果从存储层查不到数据则不写入缓存层。\n正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。\n缓存穿透问题可能会使后端存储负载加大，由于很多后端存储不具备高并发性，甚至可能造成后端存储宕掉。")]),t._v(" "),v("h4",{attrs:{id:"解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("缓存空值。当一个查询返回的数据为空时，仍把这个空结果进行缓存。但对空值做了缓存意味着缓存层占用了更多的内存空间，因此需要对这类缓存数据设置一个较短的过期时间，控制在5分钟之内，让其自动销毁。")])]),t._v(" "),v("li",[v("p",[t._v("布隆过滤器拦截。将所有可能存在的数据哈希到一个足够大的"),v("code",[t._v("bitmap")]),t._v("中，一个一定不存在的数据会被 这个"),v("code",[t._v("bitmap")]),t._v("拦截掉，从而避免了对底层存储系统的查询压力。")])])]),t._v(" "),v("h3",{attrs:{id:"缓存雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩","aria-hidden":"true"}},[t._v("#")]),t._v(" 缓存雪崩")]),t._v(" "),v("blockquote",[v("p",[t._v("内容来自：https://www.cnblogs.com/charm-j/p/10375192.html")])]),t._v(" "),v("p",[t._v("对于系统"),v("code",[t._v("A")]),t._v("，假设每天高峰期每秒"),v("code",[t._v("5000")]),t._v("个请求，本来缓存在高峰期可以扛住每秒"),v("code",[t._v("4000")]),t._v("个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时"),v("code",[t._v("1")]),t._v("秒"),v("code",[t._v("5000")]),t._v("个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没用什么特别的方案来处理这个故障，DBA很着急，重启数据库，但是数据库立马又被新的流量给打死了。")]),t._v(" "),v("p",[v("a",{attrs:{"data-fancybox":"",title:"nRwprj.png",href:"https://s2.ax1x.com/2019/09/16/nRwprj.png"}},[v("img",{attrs:{src:"https://s2.ax1x.com/2019/09/16/nRwprj.png",alt:"缓存雪崩.png"}})])]),t._v(" "),v("p",[t._v("缓存雪崩的事前事中事后的解决方案如下：")]),t._v(" "),v("ul",[v("li",[t._v("事前："),v("code",[t._v("redis")]),t._v("高可用，主从+哨兵，"),v("code",[t._v("redis cluster")]),t._v("，避免全盘崩溃。")]),t._v(" "),v("li",[t._v("事中：本地"),v("code",[t._v("ehcache")]),t._v("缓存 + "),v("code",[t._v("hystrix")]),t._v("限流&降级，避免"),v("code",[t._v("MySQL")]),t._v("被打死。")]),t._v(" "),v("li",[t._v("事后："),v("code",[t._v("redis")]),t._v("持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。")])]),t._v(" "),v("p",[v("a",{attrs:{"data-fancybox":"",title:"缓存雪崩解决方案.png",href:"https://s2.ax1x.com/2019/09/16/nRwHlF.png"}},[v("img",{attrs:{src:"https://s2.ax1x.com/2019/09/16/nRwHlF.png",alt:"缓存雪崩解决方案.png"}})])]),t._v(" "),v("h2",{attrs:{id:"高并发大流量网站解决思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高并发大流量网站解决思路","aria-hidden":"true"}},[t._v("#")]),t._v(" 高并发大流量网站解决思路")]),t._v(" "),v("ol",[v("li",[t._v("将Apache服务器（3000）替换为Nginx服务器（30000），并修改配置中最大并发连接响应数")]),t._v(" "),v("li",[t._v("多增加服务器实现负载均衡")]),t._v(" "),v("li",[t._v("减少客户端在服务器的连接断开时间")]),t._v(" "),v("li",[t._v("数据库优化，语句，索引")]),t._v(" "),v("li",[t._v("数据缓存，文件缓存、内存缓存")])])])},[],!1,null,null,null);a.default=e.exports}}]);